var documenterSearchIndex = {"docs":
[{"location":"tutorials/gabor/#GPU-accelerated-Gabor-reconstruction","page":"Gabor holography","title":"GPU-accelerated Gabor reconstruction","text":"","category":"section"},{"location":"tutorials/gabor/","page":"Gabor holography","title":"Gabor holography","text":"Please refer to Gabor holography for the principles of this method. The code below is an example of performing inline holographic reconstruction using an NVIDIA GPU (CUDA.jl). Your computer needs to be ready to use NVIDIA GPUs with CUDA.jl. It reconstructs a volume of size datlenΔx x datlenΔx x slicesΔz when the camera plane is considered as the xy plane and the direction perpendicular to the camera plane, which is the optical axis, is the z axis. Furthermore, it creates an xy projection image of the reconstructed volume by taking the minimum value of the z axis profile at each pixel in the xy plane of the reconstructed volume. The operation of extracting the xy projection image from the volume can be expressed by the following equation:","category":"page"},{"location":"tutorials/gabor/","page":"Gabor holography","title":"Gabor holography","text":"mathrmxyproj(x y) = min_z left mathrmrcstvol(x y z) right","category":"page"},{"location":"tutorials/gabor/","page":"Gabor holography","title":"Gabor holography","text":"Specify the hologram you want to reconstruct and the parameters, and save the projection image as xyprojection.png. ","category":"page"},{"location":"tutorials/gabor/","page":"Gabor holography","title":"Gabor holography","text":"using ParticleHolography\nusing CUDA\nusing Images\n\n# Load hologram\nimg = load_gray2float(\"./test/holo1.png\")\n\n# Parameters\nλ = 0.6328 # Wavelength [μm] \nΔx = 10.0 # Pixel size [μm]\nz0 = 80000.0 # Optical distance between the hologram and the front surface of the reconstruction volume [μm]\nΔz = 100.0 # Optical distance between the reconstructed slices [μm]\ndatlen = 1024 # Data length\nslices = 1000 # Number of slices\n\n# Prepare the transfer functions\nd_sqr = cu_transfer_sqrt_arr(datlen, λ, Δx)\nd_tf = cu_transfer(-z0, datlen, λ, d_sqr)\nd_slice = cu_transfer(-Δz, datlen, λ, d_sqr)\n\n# Reconstruction\nd_xyproj = cu_get_reconst_xyprojection(cu(ComplexF32.(sqrt.(img))), d_tf, d_slice, slices)\n\n# Save the result\nsave(\"xyprojection_gabor.png\", Array(d_xyproj)) # Copy the d_xyproj to host memory with Array()","category":"page"},{"location":"tutorials/gabor/","page":"Gabor holography","title":"Gabor holography","text":"<div style=\"display:flex; align-items:flex-start;\">\n   <div style=\"flex:1; margin-right:10px;\">\n       <img src=\"../../assets/holo.png\" alt=\"Input hologram image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Input hologram image</p>\n   </div>\n   <div style=\"flex:1;\">\n       <img src=\"../../assets/xyprojection.png\" alt=\"Output xy projection image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Output xy projection image</p>\n   </div>\n</div>","category":"page"},{"location":"tutorials/gabor/#Index","page":"Gabor holography","title":"Index","text":"","category":"section"},{"location":"tutorials/gabor/","page":"Gabor holography","title":"Gabor holography","text":"Pages = [\"gabor.md\"]\nOrder = [:function]","category":"page"},{"location":"tutorials/gabor/#Functions","page":"Gabor holography","title":"Functions","text":"","category":"section"},{"location":"tutorials/gabor/","page":"Gabor holography","title":"Gabor holography","text":"load_gray2float\ncu_transfer_sqrt_arr\ncu_transfer\ncu_get_reconst_xyprojection","category":"page"},{"location":"tutorials/gabor/#ParticleHolography.load_gray2float","page":"Gabor holography","title":"ParticleHolography.load_gray2float","text":"load_gray2float(path)\n\nLoad a grayscale image from a file and return it as a Array{Float32, 2} array.\n\nArguments\n\npath::String: The path to the image file.\n\nReturns\n\nArray{Float32, 2}: The image as a Float32 array.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/gabor/#ParticleHolography.cu_transfer_sqrt_arr","page":"Gabor holography","title":"ParticleHolography.cu_transfer_sqrt_arr","text":"cu_transfer_sqrt_arr(datlen, wavlen, dx)\n\nCreate a CuArray of size datlen x datlen with the values of the square-root part of the transfer function.\n\nArguments\n\ndatlen::Int: The size of the CuArray.\nwavlen::AbstractFloat: The wavelength of the light.\ndx::AbstractFloat: The pixel size of the hologram.\n\nReturns\n\nCuArray{Float32,2}: The square-root part of the transfer function.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/gabor/#ParticleHolography.cu_transfer","page":"Gabor holography","title":"ParticleHolography.cu_transfer","text":"cu_transfer(z0, datLen, wavLen, d_sqr)\n\nCreate a CuArray of size datLen x datLen with the values of the transfer function for a given propagated distance z0. d_sqr can be obtained with cutransfersqrtarr(datlen, wavlen, dx).\n\nArguments\n\nz0::AbstractFloat: The distance to propagate the wave.\ndatLen::Int: The size of the CuArray.\nwavLen::AbstractFloat: The wavelength of the light.\nd_sqr::CuArray{Float32,2}: The square of the distance from the center of the hologram, obtained with cutransfersqrtarr(datlen, wavlen, dx).\n\nReturns\n\nCuArray{ComplexF32,2}: The transfer function for the propagation.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/gabor/#ParticleHolography.cu_get_reconst_xyprojection","page":"Gabor holography","title":"ParticleHolography.cu_get_reconst_xyprojection","text":"cu_get_reconst_xyprojectin(light_field, transfer_front, transfer_dz, slices)\n\nGet the XY projection of the reconstructed volume from the light field light_field using the transfer functions transfer_front and transfer_dz. transfer_front propagates the light field to the front of the volume, and transfer_dz propagates the light field between the slices. slices is the number of slices in the volume.\n\nArguments\n\nlight_field::CuArray{ComplexF32,2}: The light_field to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuArray{ComplexF32,2}: The transfer function to propagate the light field to the front of the volume.\ntransfer_dz::CuArray{ComplexF32,2}: The transfer function to propagate the light field between the slices.\nslices::Int: The number of slices in the volume.\n\nReturns\n\nCuArray{Float32,2}: The XY projection of the reconstructed volume.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/pr/#Phase-retrieval-holography","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"","category":"section"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"Please refer to Phase retrieval holography for the principles of this method. Below, we show the necessary procedures and an implementation example for reconstructing using this method.","category":"page"},{"location":"tutorials/pr/#Bundle-adjustment","page":"Phase retrieval holography","title":"Bundle adjustment","text":"","category":"section"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"We perform bundle adjustment [10] to correct for rotational and aberrational misalignments between the two camera views in the xyplane. First, for a pair of images with densely distributed features throughout the field of view, such as a glass plate with printed random dots, we create a vector map of displacement amounts (right figure below) by calculating the cross-correlation coefficients between neighboring batches between the two images, similar to Particle Image Velocimetry (PIV) [11]. This map represents the displacement of img2 relative to the reference image img1. By determining the image transformation coefficients bma that make this map nearly zero throughout, alignment is achieved.","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"beginaligned\nx = a_1 + a_2 x + a_3 y + a_4 x^2 + a_5 xy + a_6 y^2 \ny = a_7 + a_8 x + a_9 y + a_10 x^2 + a_11 xy + a_12 y^2\nendaligned","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"Prepare a set of benchmark images, such as a glass plate with printed random dots. The following are Gabor reconstruction images of random dot holograms.","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"<div style=\"display:flex; align-items:flex-start;\">\n   <div style=\"flex:1; margin-right:10px;\">\n       <img src=\"../../assets/impcam1_enhanced.png\" alt=\"Camera 1 image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Camera 1 image</p>\n   </div>\n   <div style=\"flex:1;\">\n       <img src=\"../../assets/impcam2_enhanced.png\" alt=\"Camera 2 image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Camera 2 image</p>\n   </div>\n</div>","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"We perform bundle adjustment on these images. If verbose=true is specified, the images before and after the bundle adjustment transformation and the displacement map are saved. If not specified (default is verbose=false), only the transformation coefficients are returned.","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"using ParticleHolography\n\n# Load images\nimg1 = load_gray2float(\"./test/impcam1_enhanced.png\")\nimg2 = load_gray2float(\"./test/impcam2_enhanced.png\")\n\n# Bundle adjustment\ncoeffs = get_distortion_coefficients(img1, img2, verbose=true)","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"12-element Vector{Float64}:\n1.1502560374425654\n0.9971390059912079\n0.005022879500243858\n9.62795044814447e-7\n-7.032017562352377e-7\n1.3542774090666107e-7\n5.521164421321545\n-0.005516712482369036\n1.0009145355970703\n-3.4727403247879636e-8\n7.851521359601221e-7\n-1.749346158409748e-6","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"(Image: Before bundle adjustment) Before bundle adjustment","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"(Image: After bundle adjustment) After bundle adjustment","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"Using the coefficient array obtained in this way, we correct the distortion of the captured images.","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"img2_corrected = quadratic_distortion_correction(img2, coeffs)","category":"page"},{"location":"tutorials/pr/#Reconstruction","page":"Phase retrieval holography","title":"Reconstruction","text":"","category":"section"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"using ParticleHolography\nusing CUDA\nusing Images\n\n# Load hologram\nimg1 = load_gray2float(\"./test/holo1.png\")\nimg2 = load_gray2float(\"./test/holo2.png\")\n\n# Parameters\nλ = 0.6328 # Wavelength [μm] \nΔx = 10.0 # Pixel size [μm]\nz0 = 80000.0 # Optical distance between the hologram and the front surface of the reconstruction volume [μm]\nΔz = 100.0 # Optical distance between the reconstructed slices [μm]\ndatlen = 1024 # Data length\nslices = 1000 # Number of slices\n\n# Parameters for phase retrieval holography\nprz = 80000.0 # Distance between the two holograms [μm]\npriter = 20 # Number of iterations of the Gerchberg-Saxton algorithm\n\n# Prepare the transfer functions\nd_sqr = cu_transfer_sqrt_arr(datlen, λ, Δx)\nd_tf = cu_transfer(z0, datlen, λ, d_sqr)\nd_slice = cu_transfer(Δz, datlen, λ, d_sqr)\nd_pr = cu_transfer(prz, datlen, λ, d_sqr)\nd_pr_inv = cu_transfer(-prz, datlen, λ, d_sqr)\n\n# Image correction\nimg2_corrected = quadratic_distortion_correction(img2, coeffs)\n\n# Retrieve phase information\nd_holo = cu_phase_retrieval_holo(cu(img1), cu(img2_corrected), d_pr, d_pr_inv, priter, datlen)\n\n# Reconstruction\nd_xyproj = cu_get_reconst_xyprojection(d_holo, d_tf, d_slice, slices)\n\n# Save the result\nsave(\"xyprojection_pr.png\", Array(d_xyproj)) # Copy the d_xyproj to host memory with Array()","category":"page"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"<div style=\"display:flex; align-items:flex-start;\">\n   <div style=\"flex:1; margin-right:10px;\">\n       <img src=\"../../assets/holo.png\" alt=\"Input hologram image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Input hologram image</p>\n   </div>\n   <div style=\"flex:1;\">\n       <img src=\"../../assets/xyprojection_pr.png\" alt=\"Output xy projection image\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Output xy projection image</p>\n   </div>\n</div>","category":"page"},{"location":"tutorials/pr/#Index","page":"Phase retrieval holography","title":"Index","text":"","category":"section"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"Pages = [\"pr.md\"]\nOrder = [:function]","category":"page"},{"location":"tutorials/pr/#Functions","page":"Phase retrieval holography","title":"Functions","text":"","category":"section"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"get_distortion_coefficients\nquadratic_distortion_correction\ncu_phase_retrieval_holo","category":"page"},{"location":"tutorials/pr/#ParticleHolography.get_distortion_coefficients","page":"Phase retrieval holography","title":"ParticleHolography.get_distortion_coefficients","text":"get_distortion_coeficients(img1, img2, gridSize = 128, intrSize = 128, srchSize = 256)\n\nGet the distortion coefficients from the two images img1 and img2. The default grid size is 128, the default search size is 256, and the default image size is 128.\n\nArguments\n\nimg1::Array{<:AbstractFloat,2}: The first image.\nimg2::Array{<:AbstractFloat,2}: The second image.\ngridSize::Int: The size of the grid.\nintrSize::Int: The size of the search.\nsrchSize::Int: The size of the search.\n\nReturns\n\nVector{<:AbstractFloat}: The distortion coefficients.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/pr/#ParticleHolography.quadratic_distortion_correction","page":"Phase retrieval holography","title":"ParticleHolography.quadratic_distortion_correction","text":"quadratic_distortion_correction(img, coefa)\n\nCorrect the quadratic distortion in the grayscale image img using the coefficients coefa. img have to be square, and coefa have to be a vector of 12 coefficients.\n\nArguments\n\nimg::Array{<:AbstractFloat,2}: The image to correct.\ncoefa::Vector{<:AbstractFloat}: The coefficients to correct the distortion.\n\nReturns\n\nArray{AbstractFloat,2}: The corrected image.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/pr/#ParticleHolography.cu_phase_retrieval_holo","page":"Phase retrieval holography","title":"ParticleHolography.cu_phase_retrieval_holo","text":"cu_phase_retrieval_holo(holo1, holo2, transfer, invtransfer, priter, datlen)\n\nPerform the Gerchberg-Saxton algorithm-based phase retrieving on two holograms and return the retrieved light field at the z-coordinate point of holo1. The algorithm is repeated priter times. holo1 and holo2 are the holograms (I = |phi|^2) of the object at two different z-coordinates. transfer and invtransfer are the transfer functions for the propagation from holo1 to holo2 and vice versa. datlen is the size of the holograms.\n\nArguments\n\nholo1::CuArray{Float32,2}: The hologram at the z-cordinate of closer to the object.\nholo2::CuArray{Float32,2}: The hologram at the z-coordinate of further from the object.\ntransfer::CuArray{ComplexF32,2}: The transfer function from holo1 to holo2.\ninvtransfer::CuArray{ComplexF32,2}: The transfer function from holo2 to holo1.\npriter::Int: The number of iterations to perform the algorithm.\ndatlen::Int: The size of the holograms.\n\nReturns\n\nCuArray{ComplexF32,2}: The retrieved light field at the z-coordinate of holo1.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/pr/#References","page":"Phase retrieval holography","title":"References","text":"","category":"section"},{"location":"tutorials/pr/","page":"Phase retrieval holography","title":"Phase retrieval holography","text":"岡谷貴之. バンドルアジャストメント. 研究報告コンピュータビジョンとイメージメディア (CVIM) 2009–37, 1–16 (2009).\n\n\n\nC. E. Willert and M. Gharib. Digital particle image velocimetry. Experiments in Fluids 10–4, 181–193 (1991).\n\n\n\n","category":"page"},{"location":"whats_inline_holography/#Gabor's-inline-holography","page":"What's inline holography?","title":"Gabor's inline holography","text":"","category":"section"},{"location":"whats_inline_holography/#Introduction","page":"What's inline holography?","title":"Introduction","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"Holography is an imaging and measurement technique first proposed by D. Gabor in 1948 [1]. The interference pattern between the object light, which is diffracted by obstacles such as particles, and a reference light is recorded on a photosensitive material like a film, which is called a hologram. When the hologram is illuminated with a reconstruction light, the original light field is partially reproduced. In the case of small opaque objects like particles, the reconstructed light field is obstructed at the particle positions, appearing as dark images in the reconstruction. This allows the 3D position and shape of the objects to be observed. Currently, photosensitive materials have been replaced by digital cameras, and hologram reconstruction is commonly performed using digital image processing techniques such as numerical light propagation calculations. In an in-line holography setup, the coherent parallel light, the object observation volume, and the camera plane are all arranged along the same axis, eliminating the need to separate the object and reference light, and simplifying the reconstruction calculation. This article explains the light propagation calculation for parallel light, hologram recording and reconstruction, and the phase retrieval method, which is an advanced technique derived from Gabor holography.","category":"page"},{"location":"whats_inline_holography/#Collimated-light-propagation","page":"What's inline holography?","title":"Collimated light propagation","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"The propagation of parallel light follows the Helmholtz equation and can be calculated quickly and accurately using the angular spectrum method [2] [3]. Defining the optical axis of the parallel light as the z axis and the plane perpendicular to it as the xy plane, the wavefront of the parallel light at z=z_0 is denoted as psi(x y z_0). The light field propagated by Delta z in the positive z direction is given by the following equation:","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"psi(xyz_0 + Delta z) = mathcalF^-1left mathcalFpsi(xyz_0) cdot expleft( fracmathrmj2pi Delta zlambda sqrt1-left( lambda alpha right)^2 - left( lambda beta right)^2 right) right","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"Here, mathcalF denotes the two-dimensional Fourier transform, alpha beta are the Fourier domain variables corresponding to xy, and lambda is the wavelength. This equation shows that by Fourier transforming the wavefront of the parallel light, multiplying it by the transfer function H_Delta z=expleft( fracmathrmj2pi Delta zlambda sqrt1-left( lambda alpha right)^2 - left( lambda beta right)^2 right), and then performing an inverse Fourier transform, the light field propagated by Delta z in the positive z direction can be obtained.","category":"page"},{"location":"whats_inline_holography/#Hologram-recording-(Computer-generated-holography)","page":"What's inline holography?","title":"Hologram recording (Computer generated holography)","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"Holography is a technique for reconstructing 3D images from obtained holograms, but it is also possible to numerically generate holograms by modeling the objects and their arrangements. Generally, an opaque particle with radius r_0 located at (x_0y_0z_0) can be treated as a circular disk with zero thickness on the object plane x_0-y_0 [4]. The object plane A_0 is represented as follows:","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"A_0(xy) = begincases\n1  textif quad (x-x_0)^2 + (y-y_0)^2 leq r_0^2 \n0  textotherwise\nendcases","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"The diffraction pattern of the particle appears on the hologram as the parallel light is blocked at the points where the object plane has a value of 1. The hologram can be calculated using the following equation:","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"I(xy z_0+Delta z) = left mathcalF^-1left mathcalFpsi(xyz_0)cdot left(1-A_0right) cdot H_Delta z right right^2","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"\\psi(x,y;z_0) is the wavefront of the parallel light just before passing through the object plane. If no objects exist before this point, the phase at each point can be set to 0, and we can assume psi(xyz_0)=1. Even if objects exist before this point, we can calculate the light field propagated from the position of the farthest particle by setting the phase there to 0 and using the same method as in the above equation. Since the hologram is the intensity distribution of the light field, it is represented by the square of the amplitude of the wavefront. The light field is a complex number, so this calculation involves taking the product with its complex conjugate.","category":"page"},{"location":"whats_inline_holography/#gabor_explain","page":"What's inline holography?","title":"Hologram reconstruction (Gabor holography)","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"It is possible to reconstruct a hologram by directly propagating the intensity distribution of the light field, which is the hologram, in the negative z direction [4]. However, to maintain consistency with the phase retrieval method, which will be explained later, the reconstructed wavefront is taken as the square root of the hologram.","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"psi(xyz_0) = mathcalF^-1left mathcalFsqrtI(xyz_0+Delta z) cdot expleft( frac-mathrmj2pi Delta zlambda sqrt1-left( lambda alpha right)^2 - left( lambda beta right)^2 right) right","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"Generally, the particle positions are unknown during reconstruction. By varying the reconstruction distance -Delta z throughout the observation volume, the particle positions within the volume can be determined. In practice, the wavefront is first propagated to the front surface of the observation volume closest to the camera using the transfer function for the distance to this surface. Then, transfer functions with finer reconstruction intervals are generated, and the wavefront is propagated at each interval to create z-direction slices of the observation volume. This approach requires the generation of only two transfer functions.","category":"page"},{"location":"whats_inline_holography/#Twin-image-problem","page":"What's inline holography?","title":"Twin image problem","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"In the hologram reconstruction equation above, the square root of the hologram is treated as the light field at that point, which naturally leads to the loss of phase information from the hologram. Consequently, the intensity of the reconstructed particle images does not match the values of the transmission function (defined as (1 - object plane)). For more details on these issues, refer to [5] and [6].","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"(Image: gabor reconstruction) Gabor reconstruction and its intensity profile","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"If the phase information of the hologram could be restored to obtain an ideal reconstruction, as shown below, the threshold for particle detection could be lowered, resulting in improved particle detection performance. In the figure below, the restoration of phase information eliminates the conjugate image in the reconstruction, and the profile closely matches the correct transmission function plot.","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"(Image: phase retrieval) Phase retrieved reconstruction and its intensity profile","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"The method that achieves this is phase retrieval holography [7] using the Gerchberg-Saxton algorithm [8].","category":"page"},{"location":"whats_inline_holography/#pr_explain","page":"What's inline holography?","title":"Phase retrieval holography","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"Phase retrieval holography is a technique for reconstructing the optical wavefront, including phase information, from a pair of simultaneous holograms captured at two points separated by a propagation distance Delta z_p from the object. Let's denote the hologram closer to the object plane as I_1 and the other as I_2. Using the same indexing, we define the optical wavefront psi and its phase distribution phi. The following iterative operation (Gerchberg-Saxton algorithm) is repeated for the two holograms:","category":"page"},{"location":"whats_inline_holography/#Initial-condition","page":"What's inline holography?","title":"Initial condition","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"phi_1 = 0 quad psi_1 = sqrtI_1 expleft( mathrmjphi_1 right)","category":"page"},{"location":"whats_inline_holography/#STEP-1","page":"What's inline holography?","title":"STEP 1","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"psi_2 = mathcalF^-1left mathcalFpsi_1 cdot H_Delta z_p right \nphi_2 = argleft mathcalFpsi_2 right","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"The wavefront psi_1 is propagated by the hologram separation distance Delta z_p to calculate the wavefront psi_2, and its argument is saved as the phase distribution phi_2.","category":"page"},{"location":"whats_inline_holography/#STEP-2","page":"What's inline holography?","title":"STEP 2","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"psi_2 = sqrtI_2 expleft( mathrmjphi_2 right)","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"The wavefront psi_2 is redefined by the square root of the hologram I_2 and the phase distribution phi_2.","category":"page"},{"location":"whats_inline_holography/#STEP-3","page":"What's inline holography?","title":"STEP 3","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"psi_1 = mathcalF^-1left mathcalFpsi_2 cdot H_-Delta z_p right \nphi_1 = argleft mathcalFpsi_1 right","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"The wavefront psi_2is back-propagated by the hologram separation distance Delta z_p to calculate the wavefront psi_1, and its argument is saved as the phase distribution phi_1.","category":"page"},{"location":"whats_inline_holography/#STEP-4","page":"What's inline holography?","title":"STEP 4","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"psi_1 = sqrtI_1 expleft( mathrmjphi_1 right)","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"The wavefront psi_1 is redefined by the square root of the hologram I_1 and the phase distribution phi_1.","category":"page"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"For details such as the number of iterations of the above algorithm and camera arrangement, please refer to the literature such as [9].","category":"page"},{"location":"whats_inline_holography/#References","page":"What's inline holography?","title":"References","text":"","category":"section"},{"location":"whats_inline_holography/","page":"What's inline holography?","title":"What's inline holography?","text":"D. Gabor. A new microscopic principle. Nature 161, 777–778 (1948).\n\n\n\nJ. W. Goodman. Introduction to Fourier Optics –3rd ed. (Roberts and Company publishers, 2005); pp. 42–62.\n\n\n\nM. A. T. M. Kreis and W. P. Jüptner. Methods of digital holography: a comparison. In Optical Inspection and Micromeasurements II, SPIE 3098, 224–233 (1997).\n\n\n\nC. S. Vikram. Particle Field Holography (Cambridge University Press, 1992); p. 34.\n\n\n\nJ. Katz and J. Sheng. Applications of holography in fluid mechanics and particle dynamics. Annual Review of Fluid Mechanics 42, 531–555 (2010).\n\n\n\nH. Meng and F. Hussain. In-line recording and off-axis viewing technique for holographic particle velocimetry. Applied Optics 34–11, 1827–1840 (1995).\n\n\n\nG. Liu and P. Scott. Phase retrieval and twin-image elimination for in-line Fresnel holograms. Journal of the Optical Society of America A 4–1, 159–165 (1987).\n\n\n\nR. W. Gerchberg and W. O. Saxton. A practical algorithm for the determination of phase from image and diffraction plane pictures. Optik 35–2, 237–246 (1972).\n\n\n\nY. Tanaka, S. Tani and S. Murata. Phase retrieval method for digital holography with two cameras in particle measurement. Optics Express 24–22, 25233–25241 (2016).\n\n\n\n","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"This is the reference documentation for the ParticleHolography package.","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Functions","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ParticleHolography]","category":"page"},{"location":"reference/#ParticleHolography.cu_connected_component_labeling-Tuple{Any}","page":"Reference","title":"ParticleHolography.cu_connected_component_labeling","text":"cu_connected_component_labeling(input_img)\n\n8-way connected component labeling on binary image based on the article by Playne and Hawick https://ieeexplore.ieee.org/document/8274991 and the implementation by FolkeV https://github.com/FolkeV/CUDA_CCL. It works using the CUDA.jl package and NVIDIA GPUs.\n\nArguments\n\ninput_img::CuArray{Float32, 2}: Input binary image.\n\nReturns\n\noutput_img::CuArray{UInt32, 2}: Output labeled image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_get_reconst_vol-Tuple{CUDA.CuArray{ComplexF32, 2}, CUDA.CuArray{ComplexF32, 2}, CUDA.CuArray{ComplexF32, 2}, Int64}","page":"Reference","title":"ParticleHolography.cu_get_reconst_vol","text":"cu_get_reconst_vol(holo, transfer_front, transfer_dz, slices)\n\nReconstruct the observation volume from the light field light_field using the transfer functions transfer_front and transfer_dz. transfer_front propagates the light field to the front of the volume, and transfer_dz propagates the light field between the slices. slices is the number of slices in the volume.\n\nArguments\n\nlight_field::CuArray{ComplexF32,2}: The light_field to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuArray{ComplexF32,2}: The transfer function to propagate the light field to the front of the volume.\ntransfer_dz::CuArray{ComplexF32,2}: The transfer function to propagate the light field between the slices.\nslices::Int: The number of slices in the volume.\n\nReturns\n\nCuArray{Float32,3}: The reconstructed complex amplitude volume.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_get_reconst_vol_and_xyprojection-Tuple{CUDA.CuArray{ComplexF32, 2}, CUDA.CuArray{ComplexF32, 2}, CUDA.CuArray{ComplexF32, 2}, Int64}","page":"Reference","title":"ParticleHolography.cu_get_reconst_vol_and_xyprojection","text":"cu_get_reconst_vol_and_xyprojection(light_field, transfer_front, transfer_dz, slices)\n\nReconstruct the observation volume from the light field light_field and get the XY projection of the volume using the transfer functions transfer_front and transfer_dz. transfer_front propagates the light field to the front of the volume, and transfer_dz propagates the light field between the slices. slices is the number of slices in the volume.\n\nArguments\n\nlight_field::CuArray{ComplexF32,2}: The light_field to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuArray{ComplexF32,2}: The transfer function to propagate the light field to the front of the volume.\ntransfer_dz::CuArray{ComplexF32,2}: The transfer function to propagate the light field between the slices.\nslices::Int: The number of slices in the volume.\n\nReturns\n\nCuArray{Float32,3}: The reconstructed volume.\nCuArray{Float32,2}: The XY projection of the reconstructed volume.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_get_reconst_xyprojection-Tuple{CUDA.CuArray{ComplexF32, 2}, CUDA.CuArray{ComplexF32, 2}, CUDA.CuArray{ComplexF32, 2}, Int64}","page":"Reference","title":"ParticleHolography.cu_get_reconst_xyprojection","text":"cu_get_reconst_xyprojectin(light_field, transfer_front, transfer_dz, slices)\n\nGet the XY projection of the reconstructed volume from the light field light_field using the transfer functions transfer_front and transfer_dz. transfer_front propagates the light field to the front of the volume, and transfer_dz propagates the light field between the slices. slices is the number of slices in the volume.\n\nArguments\n\nlight_field::CuArray{ComplexF32,2}: The light_field to reconstruct. In Gabor's holography, this is the square root of the hologram.\ntransfer_front::CuArray{ComplexF32,2}: The transfer function to propagate the light field to the front of the volume.\ntransfer_dz::CuArray{ComplexF32,2}: The transfer function to propagate the light field between the slices.\nslices::Int: The number of slices in the volume.\n\nReturns\n\nCuArray{Float32,2}: The XY projection of the reconstructed volume.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_phase_retrieval_holo-Tuple{CUDA.CuArray{Float32, 2}, CUDA.CuArray{Float32, 2}, CUDA.CuArray{ComplexF32, 2}, CUDA.CuArray{ComplexF32, 2}, Int64, Int64}","page":"Reference","title":"ParticleHolography.cu_phase_retrieval_holo","text":"cu_phase_retrieval_holo(holo1, holo2, transfer, invtransfer, priter, datlen)\n\nPerform the Gerchberg-Saxton algorithm-based phase retrieving on two holograms and return the retrieved light field at the z-coordinate point of holo1. The algorithm is repeated priter times. holo1 and holo2 are the holograms (I = |phi|^2) of the object at two different z-coordinates. transfer and invtransfer are the transfer functions for the propagation from holo1 to holo2 and vice versa. datlen is the size of the holograms.\n\nArguments\n\nholo1::CuArray{Float32,2}: The hologram at the z-cordinate of closer to the object.\nholo2::CuArray{Float32,2}: The hologram at the z-coordinate of further from the object.\ntransfer::CuArray{ComplexF32,2}: The transfer function from holo1 to holo2.\ninvtransfer::CuArray{ComplexF32,2}: The transfer function from holo2 to holo1.\npriter::Int: The number of iterations to perform the algorithm.\ndatlen::Int: The size of the holograms.\n\nReturns\n\nCuArray{ComplexF32,2}: The retrieved light field at the z-coordinate of holo1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_transfer-Tuple{AbstractFloat, Int64, AbstractFloat, CUDA.CuArray{Float32, 2}}","page":"Reference","title":"ParticleHolography.cu_transfer","text":"cu_transfer(z0, datLen, wavLen, d_sqr)\n\nCreate a CuArray of size datLen x datLen with the values of the transfer function for a given propagated distance z0. d_sqr can be obtained with cutransfersqrtarr(datlen, wavlen, dx).\n\nArguments\n\nz0::AbstractFloat: The distance to propagate the wave.\ndatLen::Int: The size of the CuArray.\nwavLen::AbstractFloat: The wavelength of the light.\nd_sqr::CuArray{Float32,2}: The square of the distance from the center of the hologram, obtained with cutransfersqrtarr(datlen, wavlen, dx).\n\nReturns\n\nCuArray{ComplexF32,2}: The transfer function for the propagation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cu_transfer_sqrt_arr-Tuple{Int64, AbstractFloat, AbstractFloat}","page":"Reference","title":"ParticleHolography.cu_transfer_sqrt_arr","text":"cu_transfer_sqrt_arr(datlen, wavlen, dx)\n\nCreate a CuArray of size datlen x datlen with the values of the square-root part of the transfer function.\n\nArguments\n\ndatlen::Int: The size of the CuArray.\nwavlen::AbstractFloat: The wavelength of the light.\ndx::AbstractFloat: The pixel size of the hologram.\n\nReturns\n\nCuArray{Float32,2}: The square-root part of the transfer function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.cvgray2floatimg-Tuple{Any}","page":"Reference","title":"ParticleHolography.cvgray2floatimg","text":"cvgray2floatimg(img)\n\nConvert a OpenCV capable image to a Array{Float32, 2} image.\n\nArguments\n\nimg::Array{N0f8, 3}: The image to convert.\n\nReturns\n\nArray{Float32, 2}: The image as a Float32 array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.find_external_contours-Tuple{Any}","page":"Reference","title":"ParticleHolography.find_external_contours","text":"find_external_contours(image)\n\nFinds non-hole contours in binary images. Equivalent to CVRETREXTERNAL and CVCHAINAPPROX_NONE modes of the findContours() function provided in OpenCV.\n\nArguments\n\nimage: The binary image. \n\nReturns\n\nVector{Vector{CartesianIndex}}: A vector of contours. Each contour is a vector of CartesianIndex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.floatimg2cvgray-Tuple{Matrix{Float32}}","page":"Reference","title":"ParticleHolography.floatimg2cvgray","text":"floatimg2cvgray(img)\n\nConvert a Array{Float32, 2} image to a OpenCV capable image.\n\nArguments\n\nimg::Array{Float32, 2}: The image to convert.\n\nReturns\n\nArray{N0f8, 3}: The image as a OpenCV capable image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.getErrorVec","page":"Reference","title":"ParticleHolography.getErrorVec","text":"getErrorVec(vecMap, coefa, gridSize = 128, imgSize = 1024)\n\nReturn the vector `errorVec` obtained by calculating the difference between `targetX` `targetY` and `procX` `procY` obtained by converting `targetX` `targetY` from the `gridx` `gridy` set in the first image to the second image. Also returns `gridx` `gridy` for Jacobian acquisition.\n\nArguments\n\nvecMap: The PIV map.\ncoefa: The coefficients for the quadratic distortion correction.\ngridSize: The size of the grid.\nimgSize: The size of the image.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.getYacobian","page":"Reference","title":"ParticleHolography.getYacobian","text":"getYacobian(imgSize = 1024, gridSize = 128)\n\nGet the Jacobian matrix for the quadratic distortion correction. The default image size is 1024, and the grid size is 128.\n\nArguments\n\nimgSize::Int: The size of the image.\ngridSize::Int: The size of the grid.\n\nReturns\n\nArray{Float64,2}: The Jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ParticleHolography.get_distortion_coefficients-Tuple{Matrix{<:AbstractFloat}, Matrix{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.get_distortion_coefficients","text":"get_distortion_coeficients(img1, img2, gridSize = 128, intrSize = 128, srchSize = 256)\n\nGet the distortion coefficients from the two images img1 and img2. The default grid size is 128, the default search size is 256, and the default image size is 128.\n\nArguments\n\nimg1::Array{<:AbstractFloat,2}: The first image.\nimg2::Array{<:AbstractFloat,2}: The second image.\ngridSize::Int: The size of the grid.\nintrSize::Int: The size of the search.\nsrchSize::Int: The size of the search.\n\nReturns\n\nVector{<:AbstractFloat}: The distortion coefficients.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.load_gray2float-Tuple{String}","page":"Reference","title":"ParticleHolography.load_gray2float","text":"load_gray2float(path)\n\nLoad a grayscale image from a file and return it as a Array{Float32, 2} array.\n\nArguments\n\npath::String: The path to the image file.\n\nReturns\n\nArray{Float32, 2}: The image as a Float32 array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.make_background-Tuple{Vector{String}}","page":"Reference","title":"ParticleHolography.make_background","text":"make_background(pathlist; mode=:mode)\n\nMake a background image from a list of image paths. The background image is calculated by taking the mean or mode of the images in the list. The default mode is :mode.\n\nArguments\n\npathlist::Vector{String}: A list of image paths. glob() can be used to generate this list.\nmode::Symbol: The mode to use for calculating the background. Options are :mean or :mode. Default is :mode.\n\nReturns\n\nArray{Float64, 2}: The background image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.modified_Cholesky_decomposition-Tuple{Matrix{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.modified_Cholesky_decomposition","text":"modified_Cholesky_decomposition(A)\n\nThis function decomposes the target matrix A to A = LDL^T. The diagonal components of the return matrix are the inverse of D, and the lower left components correspond to L. 対象行列Aを A = LDL^T に変換します。戻り値行列の対角成分は D の逆数、左下成分は L に一致します。\n\nArguments\n\nA::Array{<:AbstractFloat,2}: The target matrix.\n\nReturns\n\nArray{AbstractFloat,2}: The decomposed matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.quadratic_distortion_correction-Tuple{Matrix{<:AbstractFloat}, Vector{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.quadratic_distortion_correction","text":"quadratic_distortion_correction(img, coefa)\n\nCorrect the quadratic distortion in the grayscale image img using the coefficients coefa. img have to be square, and coefa have to be a vector of 12 coefficients.\n\nArguments\n\nimg::Array{<:AbstractFloat,2}: The image to correct.\ncoefa::Vector{<:AbstractFloat}: The coefficients to correct the distortion.\n\nReturns\n\nArray{AbstractFloat,2}: The corrected image.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ParticleHolography.simultanious_equation_solver-Tuple{Matrix{<:AbstractFloat}, Matrix{<:AbstractFloat}, Vector{<:AbstractFloat}}","page":"Reference","title":"ParticleHolography.simultanious_equation_solver","text":"simultanious_equation_solver(chlskyMat,yacob,errorArray)\n\nSolve the equation chlskyMat x = - yacob errorArray using the Cholesky decomposition matrix chlskyMat, Jacobian yacob, and error vector errorArray.\n\nArguments\n\nchlskyMat::Array{<:AbstractFloat,2}: The Cholesky decomposition matrix.\nyacob::Array{<:AbstractFloat,2}: The Jacobian matrix.\nerrorArray::Array{<:AbstractFloat,1}: The error vector.\n\nReturns\n\nArray{AbstractFloat,1}: The solution vector.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ParticleHolography","category":"page"},{"location":"#ParticleHolography","page":"Home","title":"ParticleHolography","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ParticleHolography.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for particle measurement using inline holography.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is under development, and none of the functions are guaranteed to work.","category":"page"},{"location":"#What-you-can-do-with-ParticleHolography.jl","page":"Home","title":"What you can do with ParticleHolography.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Perform inline holographic reconstruction using NVIDIA GPUs (CUDA.jl)\nDetect particles in reconstructed volumes\nVisualize the particle trajectories","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"display:flex; align-items:flex-start;\">\n   <div style=\"flex:1; margin-right:10px;\">\n       <img src=\"assets/holo.gif\" alt=\"4000 fps droplet holograms\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Droplet holograms @4000 fps</p>\n   </div>\n   <div style=\"flex:1.23;\">\n       <img src=\"assets/traj.gif\" alt=\"Particle trajectories\" style=\"max-width:100%; height:auto;\">\n       <p style=\"text-align:center;\">Particle trajectories</p>\n   </div>\n</div>","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/dainakai/ParticleHolography.jl.git\")","category":"page"},{"location":"usage/preprocessings/#Preprocessings","page":"Preprocessings","title":"Preprocessings","text":"","category":"section"},{"location":"usage/preprocessings/#Background-removal","page":"Preprocessings","title":"Background removal","text":"","category":"section"},{"location":"usage/preprocessings/","page":"Preprocessings","title":"Preprocessings","text":"Given a list of hologram paths, a background image is generated by the mean or mode of the brightness values at each pixel of the hologram. Lists of holograms can be obtained using the Glob package. It is preferable if these are time series data that record few objects. It may takes a while to process a large number of holograms. A progress bar is displayed during processing.","category":"page"},{"location":"usage/preprocessings/","page":"Preprocessings","title":"Preprocessings","text":"using ParticleHolography\nusing Glob\n\npathlist = glob(\"path/to/hologram/*.png\")\nbkg = make_background(pathlist, mode=:mode)","category":"page"},{"location":"usage/preprocessings/","page":"Preprocessings","title":"Preprocessings","text":"The mode argument can be set to :mean or :mode. The default is :mode. ","category":"page"},{"location":"usage/preprocessings/","page":"Preprocessings","title":"Preprocessings","text":"make_background","category":"page"},{"location":"usage/preprocessings/#ParticleHolography.make_background","page":"Preprocessings","title":"ParticleHolography.make_background","text":"make_background(pathlist; mode=:mode)\n\nMake a background image from a list of image paths. The background image is calculated by taking the mean or mode of the images in the list. The default mode is :mode.\n\nArguments\n\npathlist::Vector{String}: A list of image paths. glob() can be used to generate this list.\nmode::Symbol: The mode to use for calculating the background. Options are :mean or :mode. Default is :mode.\n\nReturns\n\nArray{Float64, 2}: The background image.\n\n\n\n\n\n","category":"function"}]
}
